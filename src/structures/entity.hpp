#pragma once

#include <cstdint>
#include <span>

#include <glm/glm.hpp>

struct SpriteAnimation {
    uint16_t start;       // First composition in the animation
    uint16_t end;         // Last composition in the animation
    uint16_t frame_delay; // After waiting this many frames, increment the composition number
};
static_assert(sizeof(SpriteAnimation) == 6);

struct SubSprite {
    glm::u16vec2 atlas_pos;     // Atlas coordinates, relative to the entity's base coordinates
    glm::u16vec2 composite_pos; // Position of this subsprite on the composited sprite
    glm::u16vec2 size;          // Size of the subsprite
};
static_assert(sizeof(SubSprite) == 12);

struct SpriteLayer {
    union {
        struct {
            uint8_t : 1;
            bool is_normals1 : 1;
            bool is_normals2 : 1;
            bool uv_light : 1;
            bool is_conditional : 1;
        };
        uint8_t flags;
    };

    uint8_t alpha;
    bool is_visible;
};
static_assert(sizeof(SpriteLayer) == 3);

struct SpriteData {
    glm::u16vec2 composite_size;
    uint16_t layer_count;
    uint16_t composition_count;
    uint8_t subsprite_count;
    uint8_t animation_count;

    std::vector<SpriteAnimation> animations;
    std::vector<uint8_t> compositions; // are frames
    std::vector<SubSprite> sub_sprites;
    std::vector<SpriteLayer> layers;
};

struct TileMapping {
    int internal_id;
    int asset_id;
    int tile_id;
};

// extracted from game code
constexpr TileMapping spriteMapping[] = {
    {0, 0x47, 0x160},
    {1, 0x8c, 0x161},
    {2, 0xcb, 0x16b},
    {3, 0x79, 0x93},
    {4, 0x19, 0x16d},
    {5, 0x67, 0x16f},
    {6, 0xc6, 0x121},
    {7, 199, 0x120},
    {8, 0x99, 0x17b},
    {9, 0x8f, 0x17d},
    {10, 0x9a, 0x184},
    {0xb, 0x9b, 0x186},
    {0xc, 4, 0x18c},
    {0xd, 0xd3, 0x1a0},
    {0xe, 0x90, 0x19f},
    {0xf, 10, 0x1a7},
    {0x10, 0x7e, 0x1a5},
    {0x11, 0x66, 0x1a6},
    {0x12, 0xa5, 0x1a4},
    {0x13, 0x10b, 0x30b},
    {0x14, 0x28, 0x1a8},
    {0x15, 0xdb, 0x1ac},
    {0x16, 0x5d, 0x1dc},
    {0x17, 0x5c, 5},
    {0x18, 0xf8, 0xdb},
    {0x19, 0x31, 0x40},
    {0x1a, 0xae, 0x56},
    {0x1b, 0x44, 0x43},
    {0x1c, 0x54, 0x6a},
    {0x1d, 0x5f, 0x6b},
    {0x1e, 0x5e, 0xed},
    {0x1f, 0x4b, 0x22},
    {0x20, 0x6e, 0xa3},
    {0x21, 0, 0x124},
    {0x22, 0x39, 0x125},
    {0x23, 0x12e, 0x151},
    {0x24, 0xdd, 0x127},
    {0x25, 5, 0x128},
    {0x26, 0x8e, 0x155},
    {0x27, 0x12d, 0x14b},
    {0x28, 0x97, 0x173},
    {0x29, 0x96, 0x179},
    {0x2a, 0xa8, 0x20f},
    {0x2b, 0x128, 0x213},
    {0x2c, 0x48, 0x21c},
    {0x2d, 0xa7, 0x220},
    {0x2e, 0xba, 0x221},
    {0x2f, 0x77, 0x225},
    {0x30, 0x33, 0x226},
    {0x31, 0xd0, 0x227},
    {0x32, 0x10f, 0x228},
    {0x33, 0x110, 0x229},
    {0x34, 0xbe, 0x22c},
    {0x35, 0xfb, 0x22e},
    {0x36, 0xce, 0x22f},
    {0x37, 0xcd, 0x230},
    {0x38, 0x114, 0x319},
    {0x39, 0xb6, 0x136},
    {0x3a, 0xa4, 0xce},
    {0x3b, 0x3c, 0x137},
    {0x3c, 0x3d, 0xc5},
    {0x3d, 0xd1, 0x234},
    {0x3e, 0xb7, 0x236},
    {0x3f, 0xb8, 0x30a},
    {0x40, 0x23, 0x235},
    {0x41, 0x1b, 0x238},
    {0x42, 0x26, 0x239},
    {0x43, 0x6c, 0x23b},
    {0x44, 0x6d, 0x244},
    {0x45, 0xbd, 0x245},
    {0x46, 0xef, 0x75},
    {0x47, 0xca, 0x105},
    {0x48, 0x10c, 0x247},
    {0x49, 0xa1, 0x249},
    {0x4a, 0x9f, 0x254},
    {0x4b, 0xa0, 0x255},
    {0x4c, 0x22, 0x24a},
    {0x4d, 0xd6, 0x24e},
    {0x4e, 0x55, 0x24b},
    {0x4f, 0x56, 0x24c},
    {0x50, 0x57, 0x24d},
    {0x51, 0x58, 0x25d},
    {0x52, 0x59, 0x2cb},
    {0x53, 0x5a, 0x302},
    {0x54, 0x5b, 0x308},
    {0x55, 0x11a, 0x256},
    {0x56, 0x87, 0x100},
    {0x57, 0x3b, 0x259},
    {0x58, 0xed, 0x25e},
    {0x59, 0x24, 0x25f},
    {0x5a, 0x7b, 0x260},
    {0x5b, 0x7a, 0x309},
    {0x5c, 0x2d, 0x264},
    {0x5d, 8, 0x265},
    {0x5e, 0x53, 0x26b},
    {0x5f, 0x7c, 0x26e},
    {0x60, 6, 0x271},
    {0x61, 0x80, 0x273},
    {0x62, 7, 0x279},
    {99, 0x119, 0x27c},
    {100, 0xda, 0x1bf},
    {0x65, 0x98, 0x1dd},
    {0x66, 0x46, 0x10d},
    {0x67, 200, 0x10c},
    {0x68, 0x9c, 0xfb},
    {0x69, 0x71, 0x142},
    {0x6a, 0x117, 0x28e},
    {0x6b, 0x2f, 0x291},
    {0x6c, 0x68, 0x29c},
    {0x6d, 0xaa, 0x2a2},
    {0x6e, 0x6f, 0x2a9},
    {0x6f, 0xf9, 0x2aa},
    {0x70, 0xa9, 0x2b5},
    {0x71, 0x30, 0x2ca},
    {0x72, 0xfc, 0x29b},
    {0x73, 0x92, 0x2cc},
    {0x74, 0x112, 0x2cd},
    {0x75, 0x11b, 0x2d0},
    {0x76, 0xb2, 0x2d1},
    {0x77, 0x1d, 0x31a},
    {0x78, 0x116, 0x2d2},
    {0x79, 0xc5, 0x2d7},
    {0x7a, 0x36, 0x2d8},
    {0x7b, 0xc3, 10},
    {0x7c, 0xc2, 0x8e},
    {0x7d, 0x94, 0x92},
    {0x7e, 0x93, 0xa8},
    {0x7f, 0x9e, 0x2da},
    {0x80, 0xb0, 0x2e7},
    {0x81, 0xfa, 0x2e8},
    {0x82, 0x3a, 0x2e9},
    {0x83, 0x1f, 0x301},
    {0x84, 0x82, 0x2ea},
    {0x85, 0x83, 0x2eb},
    {0x86, 0x84, 0x2ec},
    {0x87, 0xd7, 0x2ee},
    {0x88, 0xbc, 0x2ef},
    {0x89, 0x37, 0x2ed},
    {0x8a, 0x88, 0x2f0},
    {0x8b, 0x85, 0x2f1},
    {0x8c, 0x78, 0x2ff},
    {0x8d, 0x3f, 0x300},
    {0x8e, 0xbb, 0x303},
    {0x8f, 0xa3, 0x44},
    {0x90, 0x70, 0x306},
    {0x91, 0xc9, 0x314},
    {0x92, 0x21, 0x315},
    {0x93, 0x6a, 0x31c},
    {0x94, 0x69, 0x31d},
    {0x95, 0x95, 0x31e},
    {0x96, 0x27, 799},
    {0x97, 0x35, 0x323},
    {0x98, 0x7f, 0x324},
    {0x99, 0x20, 0x32e},
    {0x9a, 0x1c, 0x330},
    {0x9b, 0xa2, 0x333},
    {0x9c, 0xd9, 0x334},
    {0x9d, 0xaf, 0x33e},
};

inline SpriteData parse_sprite(std::span<const uint8_t> data) {
    if(data.size() < 0x30) {
        throw std::runtime_error("invalid sprite header size");
    }
    auto ptr = (char*)data.data();

    auto magic = *(uint32_t*)ptr;
    if(magic != 0x0003AC1D) {
        throw std::runtime_error("invalid sprite header");
    }

    SpriteData out;
    out.composite_size.x = *(uint16_t*)(ptr + 4);
    out.composite_size.y = *(uint16_t*)(ptr + 6);
    out.layer_count = *(uint16_t*)(ptr + 8);
    out.composition_count = *(uint16_t*)(ptr + 10);
    out.subsprite_count = *(uint8_t*)(ptr + 12);
    out.animation_count = *(uint8_t*)(ptr + 13);

    auto anim_size = out.animation_count * sizeof(SpriteAnimation);
    auto comp_size = out.layer_count * out.composition_count;
    auto subs_size = out.subsprite_count * sizeof(SubSprite);
    auto layer_size = out.layer_count * sizeof(SpriteLayer);

    if(data.size() < 0x30 + anim_size + comp_size + subs_size + layer_size) {
        throw std::runtime_error("invalid sprite data size");
    }

    ptr += 0x30;

    out.animations = {(SpriteAnimation*)ptr, ((SpriteAnimation*)ptr) + out.animation_count};
    ptr += anim_size;

    out.compositions = {ptr, ptr + comp_size};
    ptr += comp_size;

    out.sub_sprites = {(SubSprite*)ptr, ((SubSprite*)ptr) + out.subsprite_count};
    ptr += subs_size;

    out.layers = {(SpriteLayer*)ptr, (SpriteLayer*)(ptr) + out.layer_count};

    return out;
}
